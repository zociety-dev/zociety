#!/usr/bin/env bash
# zloop - Zociety's autonomous loop with dynamic completion checking
#
# Usage:
#   bin/zloop [max-iterations]
#
# Environment:
#   ZLOOP_TIMEOUT=300   Timeout per iteration in seconds (default: 300)
#   ZLOOP_DEBUG=1       Enable debug output
#   ZLOOP_VERBOSE=1     Pass --verbose to claude
#
# Runs Claude Code iterations until bin/zloop-complete returns 0.
# Each iteration reads PROMPT.md and follows instructions.
# State persists in git between iterations.

set -euo pipefail

MAX_ITERATIONS="${1:-60}"
ITERATION=0
PROMPT="Read PROMPT.md and follow its instructions."
TIMEOUT_SECS="${ZLOOP_TIMEOUT:-300}"
DEBUG="${ZLOOP_DEBUG:-0}"
VERBOSE="${ZLOOP_VERBOSE:-0}"

debug() {
  if [[ "$DEBUG" == "1" ]]; then
    echo "[debug] $*" >&2
  fi
}

echo "=== Zociety Loop ==="
echo "Max iterations: $MAX_ITERATIONS"
echo "Timeout per iteration: ${TIMEOUT_SECS}s"
if [[ "$DEBUG" == "1" ]]; then
  echo "Debug mode: enabled"
fi
echo ""

while true; do
  ITERATION=$((ITERATION + 1))

  # Write state for zheap-death to read
  mkdir -p .claude
  cat > .claude/zloop.state << EOF
iteration: $ITERATION
max: $MAX_ITERATIONS
EOF

  # Check completion BEFORE each iteration
  debug "Checking if loop should complete..."
  if bin/zloop-complete; then
    echo ""
    echo "=== Loop Complete ==="
    echo "Iterations: $ITERATION"
    bin/zstate | jq '{action, phase, genesis}'
    rm -f .claude/zloop.state
    exit 0
  fi

  # Check iteration limit
  if [[ $ITERATION -gt $MAX_ITERATIONS ]]; then
    echo ""
    echo "=== Max Iterations Reached ==="
    echo "Stopped after $MAX_ITERATIONS iterations"
    bin/zstate | jq '{action, phase, genesis}'
    exit 1
  fi

  echo ""
  echo "=== Iteration $ITERATION/$MAX_ITERATIONS ==="
  bin/zstate | jq -c '{action, phase}'
  echo ""

  # Build claude command arguments for autonomous operation:
  #   --print: Output result without interactive mode
  #   --dangerously-skip-permissions: Skip tool permission prompts
  #   --strict-mcp-config: Skip all MCP servers (they may hang in containers)
  #   --no-session-persistence: Don't save sessions (avoids file conflicts)
  #   --tools default: Use default tools only
  CLAUDE_ARGS=(
    --print
    --dangerously-skip-permissions
    --strict-mcp-config
    --no-session-persistence
  )

  if [[ "$VERBOSE" == "1" ]]; then
    CLAUDE_ARGS+=(--verbose)
  fi

  CLAUDE_ARGS+=("$PROMPT")

  debug "Running: claude ${CLAUDE_ARGS[*]}"

  # Run one Claude iteration
  # The || true prevents loop exit on non-zero claude return codes
  # Note: </dev/null closes stdin to prevent claude from expecting interactive input
  if command -v timeout &>/dev/null; then
    debug "Using timeout wrapper (${TIMEOUT_SECS}s)"
    timeout "$TIMEOUT_SECS" claude "${CLAUDE_ARGS[@]}" </dev/null 2>&1 || {
      exit_code=$?
      if [[ $exit_code -eq 124 ]]; then
        echo "[zloop] Iteration timed out after ${TIMEOUT_SECS}s" >&2
      else
        debug "Claude exited with code $exit_code"
      fi
    }
  else
    claude "${CLAUDE_ARGS[@]}" </dev/null 2>&1 || {
      debug "Claude exited with code $?"
    }
  fi

  debug "Iteration $ITERATION complete, sleeping 1s..."
  # Small delay to avoid rate limits
  sleep 1
done
