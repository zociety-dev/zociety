#!/bin/bash
# zstate: Get current zociety state from git history
#
# Returns JSON with:
#   - cycle: current cycle number
#   - seq: sequence number in cycle
#   - phase: initial|direction|building|finishing
#   - genesis: {members, rules, stuff, complete}
#   - batch: remaining attempts (null if not set)
#   - direction: question for cycle (null if not set)
#   - action: what agent should do next
#   - last_event: type of last event
#   - last_agent: who did last event

set -e

# Find most recent event commit by searching for valid JSON with z:1 marker
# Uses jq to parse regardless of pretty-print formatting
find_last_event() {
  local count=0
  for HASH in $(git log --format=%H -n 100 2>/dev/null); do
    BODY=$(git log -1 --format=%b "$HASH" 2>/dev/null)
    # Try to parse body as JSON with z:1 schema marker
    EVENT=$(echo "$BODY" | jq -ce 'select(.z == 1)' 2>/dev/null) && {
      echo "$EVENT"
      return 0
    }
    ((count++))
    [[ $count -ge 50 ]] && break
  done
  return 1
}

LAST_EVENT=$(find_last_event || true)

if [[ -z "$LAST_EVENT" ]]; then
  # No events yet - initial state
  bin/zlog zstate "No events found - returning initial state" '{"action": "join"}' 2>/dev/null || true
  cat <<'EOF'
{
  "cycle": 1,
  "seq": 0,
  "phase": "initial",
  "genesis": {"members": 0, "rules": 0, "stuff": 0, "complete": false},
  "batch": null,
  "direction": null,
  "action": "join",
  "last_event": null,
  "last_agent": null
}
EOF
  exit 0
fi

# Log the found event
LAST_EVENT_TYPE=$(echo "$LAST_EVENT" | jq -r '.event')
LAST_EVENT_AGENT=$(echo "$LAST_EVENT" | jq -r '.agent')
bin/zlog zstate "Found last event: $LAST_EVENT_TYPE by $LAST_EVENT_AGENT" \
  "$(echo "$LAST_EVENT" | jq -c '{event: .event, agent: .agent, batch: .data.batch_remaining}')" 2>/dev/null || true

# Parse last event and compute phase and action
OUTPUT=$(echo "$LAST_EVENT" | jq -r '
  # Determine phase based on last event and state
  .phase = (
    if .event == "promise" then "stopped"
    elif .event == "heap-death" then
      if (.data.batch_remaining // 0) == 0 then "exiting"
      else "direction"
      end
    elif .event == "complete" then "archiving"
    elif .event == "direction" then "building"
    elif .state.complete then "finishing"
    else "building"
    end
  ) |

  # Determine recommended action based on event and state
  # Key insight: after [complete], must run heap-death before promise
  # After [promise], loop should stop - no further action needed
  # Direction guides contribution, not file editing
  .action = (
    if .event == "promise" then "stop"
    elif .event == "complete" then "heap-death"
    elif .event == "heap-death" then
      if (.data.batch_remaining // 0) == 0 then "promise"
      else "contribute"
      end
    elif .state.complete then "complete"
    else "contribute"
    end
  ) |

  # Build output structure
  {
    cycle: .cycle,
    seq: .seq,
    phase: .phase,
    genesis: .state,
    batch: (.data.batch_remaining // null),
    direction: (.data.question // null),
    action: .action,
    last_event: .event,
    last_agent: .agent
  }
')

# Log the computed state with explanation
ACTION=$(echo "$OUTPUT" | jq -r '.action')
PHASE=$(echo "$OUTPUT" | jq -r '.phase')
bin/zlog zstate "Computed: phase=$PHASE, action=$ACTION" \
  "$(echo "$OUTPUT" | jq -c '{phase: .phase, action: .action, batch: .batch, complete: .genesis.complete}')" 2>/dev/null || true

# Output the state
echo "$OUTPUT"
