#!/bin/bash
# zstate: Get current zociety state from git history
#
# Returns JSON with:
#   - cycle: current cycle number
#   - seq: sequence number in cycle
#   - phase: initial|direction|building|finishing
#   - genesis: {members, rules, stuff, complete}
#   - batch: remaining attempts (null if not set)
#   - direction: question for cycle (null if not set)
#   - action: what agent should do next
#   - last_event: type of last event
#   - last_agent: who did last event

set -e

# Find most recent event commit by searching for valid JSON with z:1 marker
# Uses jq to parse regardless of pretty-print formatting
find_last_event() {
  local count=0
  for HASH in $(git log --format=%H -n 100 2>/dev/null); do
    BODY=$(git log -1 --format=%b "$HASH" 2>/dev/null)
    # Try to parse body as JSON with z:1 schema marker
    EVENT=$(echo "$BODY" | jq -ce 'select(.z == 1)' 2>/dev/null) && {
      echo "$EVENT"
      return 0
    }
    ((count++))
    [[ $count -ge 50 ]] && break
  done
  return 1
}

LAST_EVENT=$(find_last_event || true)

if [[ -z "$LAST_EVENT" ]]; then
  # No events yet - initial state
  cat <<'EOF'
{
  "cycle": 1,
  "seq": 0,
  "phase": "initial",
  "genesis": {"members": 0, "rules": 0, "stuff": 0, "complete": false},
  "batch": null,
  "direction": null,
  "action": "join",
  "last_event": null,
  "last_agent": null
}
EOF
  exit 0
fi

# Parse last event and compute phase and action
echo "$LAST_EVENT" | jq -r '
  # Determine phase based on last event and state
  .phase = (
    if .event == "heap-death" then
      if (.data.batch_remaining // 0) == 0 then "exiting"
      else "direction"
      end
    elif .event == "complete" then "archiving"
    elif .event == "direction" then "building"
    elif .state.complete then "finishing"
    else "building"
    end
  ) |

  # Determine recommended action based on event and state
  # Key insight: after [complete], must run heap-death before promise
  .action = (
    if .event == "complete" then "heap-death"
    elif .event == "heap-death" then
      if (.data.batch_remaining // 0) == 0 then "promise"
      else "evolve"
      end
    elif .event == "direction" then "evolve"
    elif .state.complete then "complete"
    else "contribute"
    end
  ) |

  # Build output structure
  {
    cycle: .cycle,
    seq: .seq,
    phase: .phase,
    genesis: .state,
    batch: (.data.batch_remaining // null),
    direction: (.data.question // null),
    action: .action,
    last_event: .event,
    last_agent: .agent
  }
'
